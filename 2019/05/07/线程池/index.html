<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="线程池"><meta name="keywords" content><meta name="author" content="无言独上青楼,undefined"><meta name="copyright" content="无言独上青楼"><title>线程池【无言独上青楼】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/head.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"YR6QYQ92JO","apiKey":"d4e0ef2c7be6c96ae7293d651a2d9230","indexName":"mmm","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable接口"><span class="toc-number">1.</span> <span class="toc-text">Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池常见三种"><span class="toc-number">2.</span> <span class="toc-text">线程池常见三种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池七大参数"><span class="toc-number">3.</span> <span class="toc-text">线程池七大参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池底层工作原理"><span class="toc-number">4.</span> <span class="toc-text">线程池底层工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池四种拒绝策略"><span class="toc-number">5.</span> <span class="toc-text">线程池四种拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池实际中使用哪一个？"><span class="toc-number">6.</span> <span class="toc-text">线程池实际中使用哪一个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池合理配置线程数"><span class="toc-number">7.</span> <span class="toc-text">线程池合理配置线程数</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/head.png"></div><div class="author-info-name">无言独上青楼</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/machudong" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="https://weibo.com/5961187827/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank">微博<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="mailto:648709040@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">8</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/about">关于我</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">无言独上青楼</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">线程池</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-07 | 更新于 2019-05-07</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"></div></div></div><div class="main-content"><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><ul>
<li>实现Callable接口，第三种获得线程的方法，与Runnable相比，Callable有返回值，Runnable没有返回值。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">"AA"</span>).start();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得返回值1024</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程池常见三种"><a href="#线程池常见三种" class="headerlink" title="线程池常见三种"></a>线程池常见三种</h3><ul>
<li>线程池的底层是ThreadPoolExecutor类</li>
<li><p>线程池一共有5种，但一般常用有3种</p>
<ol>
<li><p>固定线程数 ExecutorService threadPool = Executors.newFixedThreadPool(5);<br>适用场景：执行长期的任务，性能好很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"> <span class="comment">//一池5个线程</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">               threadPool.execute(() -&gt;&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">"\t 处理业务"</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           threadPool.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-5	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-3	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-2	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-4	 处理业务</span></span><br></pre></td></tr></table></figure>
<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">      <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>主要特点：<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等候；<br>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue。</p>
</li>
<li><p>一池1个线程，ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>适用场景：一个任务一个任务执行的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor(); </span><br><span class="line"><span class="comment">//一池1个线程</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">               threadPool.execute(() -&gt;&#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">"\t 处理业务"</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           threadPool.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br></pre></td></tr></table></figure>
<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>主要特点：<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行；<br>newFixedThreadPool将corePoolSize和maximumPoolSize都设置为1，它使用的是LinkedBlockingQueue。</p>
</li>
<li><p>一池N个线程，ExecutorService threadPool = Executors.newCachedThreadPool();<br>适用场景：执行很多短期异步的小程序或者负载较低的服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();  <span class="comment">//一池N个线程</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">               threadPool.execute(() -&gt;&#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 处理业务"</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           threadPool.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//pool-1-thread-6	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-2	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-3	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-4	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-7	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-5	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-1	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-8	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-9	 处理业务</span></span><br><span class="line"><span class="comment">//pool-1-thread-10	 处理业务</span></span><br></pre></td></tr></table></figure>
<p>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">      <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>主要特点：<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程；<br>newFixedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<h3 id="线程池七大参数"><a href="#线程池七大参数" class="headerlink" title="线程池七大参数"></a>线程池七大参数</h3></li>
</ol>
</li>
</ul>
<ol>
<li>corePoolSize：线程池中的常驻核心线程数</li>
<li>maximumPoolSize，那么还是要创建非核心线程立刻执行这个任务<br>2.4 如果队列满了且正在执行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行3. 当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做超过一定的时间（）：线程池能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime：多余的空闲线程的存活时间，当前线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余空闲线程会被销毁直到corePoolSize个线程为止</li>
<li>unit：keepAliveTime的单位</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务（阻塞队列）</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般使用默认的即可</li>
<li>handler：拒绝策略，表示当队列满了并且工作线程数大于等于线程池最大线程数（maximumPoolSize）时如何来拒绝请求执行的Runnable的策略<h3 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h3></li>
<li>在创建了线程池后，等待提交过来的任务请求</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做如下判断：<br> 2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务<br> 2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列<br> 2.3 如果这时候队列满了且运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻执行这个任务<br> 2.4 如果队列满了且正在执行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：<br> 如果当前运行的线程数大于corePoolSize，那么这个线程会停掉<br> 线程池的所有任务完成后，它的线程数量最终会收缩到corePoolSize的大小<h3 id="线程池四种拒绝策略"><a href="#线程池四种拒绝策略" class="headerlink" title="线程池四种拒绝策略"></a>线程池四种拒绝策略</h3></li>
<li>new ThreadPoolExecutor.AbortPolicy();//默认，队列满了丢任务抛出异常</li>
<li>new ThreadPoolExecutor.DiscardPolicy();//队列满了丢任务不异常</li>
<li>new ThreadPoolExecutor.DiscardOldestPolicy();//将最早进入队列的任务删，之后再尝试加入队列</li>
<li>new ThreadPoolExecutor.CallerRunsPolicy();//如果添加到线程池失败，那么主线程会自己去执行该任务<h3 id="线程池实际中使用哪一个？"><a href="#线程池实际中使用哪一个？" class="headerlink" title="线程池实际中使用哪一个？"></a>线程池实际中使用哪一个？</h3></li>
</ol>
<ul>
<li><font color="red">都不使用，一般使用自定义的线程池</font><br>  原因：Executors 返回的线程池对象的弊端如下：<br>  1）FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>  2）CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li>
<li>自定义线程池  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">5</span>,</span><br><span class="line">               <span class="number">1L</span>,</span><br><span class="line">               TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">               Executors.defaultThreadFactory(),</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">               threadPool.execute(() -&gt;&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">"\t 处理业务"</span>);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           threadPool.shutdown();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程池合理配置线程数"><a href="#线程池合理配置线程数" class="headerlink" title="线程池合理配置线程数"></a>线程池合理配置线程数</h3><p>一般需要根据任务的类型来配置线程池大小：<br>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1<br>如果是IO密集型任务，参考值可以设置为2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">无言独上青楼</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://machudong.github.io/2019/05/07/线程池/">http://machudong.github.io/2019/05/07/线程池/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://machudong.github.io">无言独上青楼</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/05/08/死锁编码及定位分析/"><i class="fas fa-angle-left">&nbsp;</i><span>死锁编码及定位分析</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/05/06/集合类不安全问题/"><span>集合类不安全问题</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By 无言独上青楼</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>